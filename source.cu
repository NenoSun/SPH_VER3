#include <iostream>
#include <thrust/sort.h>
#include <thrust/device_ptr.h>
#include <stdio.h>
#include <time.h>
#include "source.cuh"
#include "MarchingCubeTable.cuh"
#include "Configuration.h"

#define ZERO 1e-12
#define BOUNDARY 0.01f


void printDeviceProp(const cudaDeviceProp &prop)
{
	printf("Device Name : %s.\n", prop.name);
	printf("totalGlobalMem : %d.\n", prop.totalGlobalMem);
	printf("sharedMemPerBlock : %d.\n", prop.sharedMemPerBlock);
	printf("regsPerBlock : %d.\n", prop.regsPerBlock);
	printf("warpSize : %d.\n", prop.warpSize);
	printf("memPitch : %d.\n", prop.memPitch);
	printf("maxThreadsPerBlock : %d.\n", prop.maxThreadsPerBlock);
	printf("maxThreadsDim[0 - 2] : %d %d %d.\n", prop.maxThreadsDim[0], prop.maxThreadsDim[1], prop.maxThreadsDim[2]);
	printf("maxGridSize[0 - 2] : %d %d %d.\n", prop.maxGridSize[0], prop.maxGridSize[1], prop.maxGridSize[2]);
	printf("totalConstMem : %d.\n", prop.totalConstMem);
	printf("major.minor : %d.%d.\n", prop.major, prop.minor);
	printf("clockRate : %d.\n", prop.clockRate);
	printf("textureAlignment : %d.\n", prop.textureAlignment);
	printf("deviceOverlap : %d.\n", prop.deviceOverlap);
	printf("multiProcessorCount : %d.\n", prop.multiProcessorCount);
}
bool initCUDA() {
	int count;

	cudaGetDeviceCount(&count);

	if (count == 0) {
		printf("There is no device.\n");
		return false;
	}

	int i = 0;

	for (i = 0; i < count; i++) {
		cudaDeviceProp deviceProp;
		if (cudaGetDeviceProperties(&deviceProp, i) == cudaSuccess)
			if (deviceProp.major >= 1) {
				break;
			}

	}

	if (i == count) {
		printf("There is no device supporting CUDA9.1 Toolkit.");
		return false;
	}

	cudaDeviceProp deviceProp;
	cudaGetDeviceProperties(&deviceProp, i);
	printDeviceProp(deviceProp);
	cudaSetDevice(i);

	return true;

}

__device__ Uint3 computeCellPosition(Float3 pos, Param* param) {
	Uint3 cellPos;
	cellPos.x = (uint)floor(pos.x / param->h);
	cellPos.y = (uint)floor(pos.y / param->h);
	cellPos.z = (uint)floor(pos.z / param->h);
	return cellPos;
}

__device__ uint computeCellHash(Uint3 cellPos, Param* param) {
	if (cellPos.x>param->gridSize.x - 1 || cellPos.y>param->gridSize.y - 1 || cellPos.z>param->gridSize.z - 1)
		return -1;

	return (uint)(cellPos.z*param->gridSize.x*param->gridSize.y + cellPos.y*param->gridSize.x + cellPos.x);
}

__device__ float dCalDistance(Float3 p1, Float3 p2) {
	return (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y) + (p1.z - p2.z)*(p1.z - p2.z);
}

// The Hash table was generated by sorting
__global__ static void generateHashTable(Particle* particles, uint* dParticleIndex, uint* dCellIndex, Param* param) {
	// Each thread represents for a particle
	int index = blockIdx.x * blockDim.x + threadIdx.x;
	if (index >= param->num_particles)
		return;
	// Compute the cell index
	uint hash = computeCellHash(computeCellPosition(particles[index].pos, param), param);
	if (hash >= param->cells_total)
		return;
	dParticleIndex[index] = index;
	dCellIndex[index] = hash;
}

void sort_particles(uint *dHash, uint *dIndex, uint num_particle)
{
	if (num_particle == 0)
	{
		return;
	}
	try {
		thrust::sort_by_key(thrust::device_ptr<uint>(dHash),
			thrust::device_ptr<uint>(dHash + num_particle),
			thrust::device_ptr<uint>(dIndex));
	}
	catch (thrust::system_error &e)
	{
		std::cerr << "CUDA error after cudaSetDevice: " << e.what() << std::endl;
		//system("pause");
	}
}

__global__
void find_start_end_kernel(uint *dStart, uint *dEnd, uint *dCellIndex, uint *dParticleIndex, uint num_particle)
{
	// For each index in the dParticleIndex
	uint index = blockIdx.x*blockDim.x + threadIdx.x;
	if (index >= num_particle)
		return;

	// If index == 0
	if (index == 0) {
		// Then we check if we have any particle
		if (dCellIndex[0] == 0xffffffff && dCellIndex[1] == 0xffffffff)
			return;
		else if (dCellIndex[1] == 0xffffffff) {
			dStart[dCellIndex[0]] = index;
			dEnd[dCellIndex[0]] = index;
			return;
		}
		else if (dCellIndex[index] == dCellIndex[index + 1])
			dStart[dCellIndex[index]] = index;
		else {
			dStart[dCellIndex[index]] = dEnd[dCellIndex[index]] = index;
			dStart[dCellIndex[index + 1]] = index + 1;
		}
	}

	else if (index == num_particle - 1) {
		if (dCellIndex[index] == 0xffffffff && dCellIndex[index - 1] == 0xffffffff)
			return;
		else if (dCellIndex[index] == 0xffffffff) {
			dEnd[dCellIndex[index - 1]] = index - 1;
		}
		else if (dCellIndex[index] == dCellIndex[index - 1])
			dEnd[dCellIndex[index]] = index;
		else {
			dStart[dCellIndex[index]] = index;
			dEnd[dCellIndex[index]] = index;
		}
	}

	else if (dCellIndex[index] == dCellIndex[index + 1]) {
		return;
	}

	else {
		if (dCellIndex[index] != 0xffffffff && dCellIndex[index + 1] == 0xffffffff) {
			dEnd[dCellIndex[index]] = index;
		}
		else {
			dEnd[dCellIndex[index]] = index;
			dStart[dCellIndex[index + 1]] = index + 1;
		}
	}
}

__global__ static void computeDensAndPres(Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex) {
	int index = threadIdx.x + blockDim.x*blockIdx.x;
	if (index >= param->num_particles)
		return;
	int hash;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(particles[index].pos, param);
	Particle *p = &(particles[index]);
	p->dens = p->pres = 0;

#ifdef KERNEL
	for (int x = -1; x <= 1; x++)
		for (int y = -1; y <= 1; y++)
			for (int z = -1; z <= 1; z++) {
				neighborPos.x = cellPos.x + x;
				neighborPos.y = cellPos.y + y;
				neighborPos.z = cellPos.z + z;
				hash = computeCellHash(neighborPos, param);
				if (hash<0 || hash >= param->cells_total)
					continue;
				if (dStart[hash] < 0 || dStart[hash] >= param->num_particles)
					continue;
				uint count = 0;
				for (count = dStart[hash]; count <= dEnd[hash]; count++) {
					Particle *current = &particles[dParticleIndex[count]];
					float distanceSquare = dCalDistance((*current).pos, particles[index].pos);
					if (distanceSquare<ZERO || distanceSquare>param->h_square)
						continue;
					p->dens = p->dens + param->mass * param->poly6_coff * pow(param->h_square - distanceSquare, 3);
					//p->dens = p->dens + param->mass * W.W(current->pos.Dist(p->pos), POLY6);
				}
			}
	p->dens = p->dens + param->self_dens;
	p->pres = (pow(p->dens / param->rest_density, 7) - 1) *param->gas_stiffness;
#endif

#ifdef SPLINE_KERNEL
	ITERATE_NEIGHBOR{
	neighborPos.x = cellPos.x + x;
	neighborPos.y = cellPos.y + y;
	neighborPos.z = cellPos.z + z;
	hash = computeCellHash(neighborPos, param);
	if (hash<0 || hash >= param->cells_total)
		continue;
	if (dStart[hash] < 0 || dStart[hash] >= param->num_particles)
		continue;
	uint count = 0;
	for (count = dStart[hash]; count <= dEnd[hash]; count++) {
		Particle *current = &particles[dParticleIndex[count]];
		float distanceSquare = dCalDistance((*current).pos, particles[index].pos);
		// 0 < r/h < 2
		float q = sqrt(distanceSquare) / param->h;
		if (q > 2 || q < 0)
			continue;
		if (q <= 1)
			p->dens += param->mass * (1 - 1.5*pow(q, 2) + 0.75*pow(q, 3)) * param->spline_coff;
		else if (q < 2)
			p->dens += param->mass * (0.25 * pow(2 - q, 3)) *param->spline_coff;
	}
	}
		// The constant term is evaluated under water height 0.4 * 0.64 m and g = 6.8
	p->pres = (pow(p->dens / param->rest_density, 7) - 1) * param->B;
#endif
}

__global__ static void computeForces(Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex) {
	int index = threadIdx.x + blockDim.x*blockIdx.x;
	int hash;
	if (index >= param->num_particles)
		return;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(particles[index].pos, param);
	Particle *p = &(particles[index]);
	float constant_term;
	p->acc.x = p->acc.y = p->acc.z = 0;
	p->grad_color.x = p->grad_color.y = p->grad_color.z = p->lplc_color = 0;

#ifdef KERNEL
	p->F_Pressure.x = p->F_Pressure.y = p->F_Pressure.z = 0;
	p->F_Viscosity.x = p->F_Viscosity.y = p->F_Viscosity.z = 0;
	p->F_SurfaceTension.x = p->F_SurfaceTension.y = p->F_SurfaceTension.z = 0;
	for (int x = -1; x <= 1; x++)
		for (int y = -1; y <= 1; y++)
			for (int z = -1; z <= 1; z++) {
				neighborPos.x = cellPos.x + x;
				neighborPos.y = cellPos.y + y;
				neighborPos.z = cellPos.z + z;
				hash = computeCellHash(neighborPos, param);
				if (hash<0 || hash >= param->cells_total)
					continue;
				if (dStart[hash] < 0 || dStart[hash] >= param->num_particles)
					continue;
				uint count = 0;
				for (count = dStart[hash]; count <= dEnd[hash]; count++) {
					Particle *current = &particles[dParticleIndex[count]];
					float distance = p->pos.Dist(current->pos);
					if (distance<ZERO || distance>param->h)
						continue;
					// To optimize the calculation process
					Particle j = (*current);
					float h_minus_r = param->h - distance;
					float h2_minus_r2 = param->h_square - distance*distance;
					Float3 delta_r = p->pos - j.pos;

					constant_term = param->mass * param->grad_spiky_coff *h_minus_r *h_minus_r / j.dens / 2.0f / distance;
					p->F_Pressure -= constant_term * (p->pres + j.pres) * delta_r;


					constant_term = param->mass * param->vicosity_coff * param->lplc_visco_coff *h_minus_r / j.dens;
					p->F_Viscosity += constant_term * (j.vel - p->vel);

					constant_term = param->mass * param->grad_poly6 * h2_minus_r2 * h2_minus_r2 / j.dens;
					p->grad_color += constant_term*delta_r;
					p->lplc_color = p->lplc_color + param->mass * param->lplc_poly6 * h2_minus_r2 * (3 * param->h_square - 7 * distance*distance) / j.dens;
				}
			}
	p->lplc_color = p->lplc_color - param->mass * param->lplc_poly6 * 3.0f * param->h_square * param->h_square / p->dens;
	float mod_surf_norm = p->grad_color.Norm();
	if (mod_surf_norm > param->l_threshold) {
		p->F_SurfaceTension = param->surf_tens_coff * p->lplc_color * p->grad_color / mod_surf_norm;
	}

#endif

#ifdef SPLINE_KERNEL
	ITERATE_NEIGHBOR{
		neighborPos.x = cellPos.x + x;
	neighborPos.y = cellPos.y + y;
	neighborPos.z = cellPos.z + z;
	hash = computeCellHash(neighborPos, param);
	if (hash<0 || hash >= param->cells_total)
		continue;
	if (dStart[hash] < 0 || dStart[hash] >= param->num_particles)
		continue;
	uint count = 0;
	for (count = dStart[hash]; count <= dEnd[hash]; count++) {
		Particle *current = &particles[dParticleIndex[count]];
		float distanceSquare = dCalDistance((*current).pos, particles[index].pos);
		float distance = sqrt(distanceSquare);
		float q = distance / param->h;
		if (q > 2 || q < 0)
			continue;
		// To optimize the calculation process
		Particle j = (*current);
		Float3 delta_r;
		delta_r.x = p->pos.x - j.pos.x;
		delta_r.y = p->pos.y - j.pos.y;
		delta_r.z = p->pos.z - j.pos.z;
		Float3 delta_v;
		delta_v.x = p->vel.x - j.vel.x;
		delta_v.y = p->vel.y - j.vel.y;
		delta_v.z = p->vel.z - j.vel.z;
		float vx = delta_v.x * delta_r.x + delta_v.y*delta_r.y + delta_v.z*delta_r.z;


		float constant_term = param->mass * ((p->pres / pow(p->dens, 2)) + (j.pres / pow(j.dens, 2))) * param->grad_spline_coff;

		if (q <= 1) {
			p->acc.x -= constant_term * (q - 4.0f / 3.0f) * delta_r.x;
			p->acc.y -= constant_term * (q - 4.0f / 3.0f) * delta_r.y;
			p->acc.z -= constant_term * (q - 4.0f / 3.0f) * delta_r.z;
			if (vx < 0) {
				constant_term = param->mass * (-2.0f* 0.35 * param->h*param->SpeedOfSound / (p->dens + j.dens))*(vx / (distanceSquare + 0.01 * param->h_square)) * param->grad_spline_coff* (q - 4.0f / 3.0f);
				p->acc.x -= constant_term * delta_r.x;
				p->acc.y -= constant_term * delta_r.y;
				p->acc.z -= constant_term * delta_r.z;
			}

			constant_term = param->surf_tens_coff * param->spline_coff* (1 - 1.5*pow(q, 2) + 0.75*pow(q, 3));
			p->acc.x -= constant_term * delta_r.x;
			p->acc.y -= constant_term * delta_r.y;
			p->acc.z -= constant_term * delta_r.z;
		}

		else if (q < 2) {
			p->acc.x -= constant_term * (pow(2 - q, 2) * q / (-3.0f))*delta_r.x;
			p->acc.y -= constant_term * (pow(2 - q, 2) * q / (-3.0f))*delta_r.y;
			p->acc.z -= constant_term * (pow(2 - q, 2) * q / (-3.0f))*delta_r.z;
			if (vx < 0) {
				constant_term = param->mass * (-2.0f* 0.35 * param->h*param->SpeedOfSound / (p->dens + j.dens))*(vx / (distanceSquare + 0.01 * param->h_square)) * param->grad_spline_coff* (pow(2 - q, 2) * q / (-3.0f));
				p->acc.x -= constant_term * delta_r.x;
				p->acc.y -= constant_term * delta_r.y;
				p->acc.z -= constant_term * delta_r.z;
			}

			constant_term = param->surf_tens_coff * (0.25 * pow(2 - q, 3)) *param->spline_coff;
			p->acc.x -= constant_term * delta_r.x;
			p->acc.y -= constant_term * delta_r.y;
			p->acc.z -= constant_term * delta_r.z;
		}
	}
	}
#endif
}

__global__ static void update(Particle* particles, Param* param) {
	int index = blockIdx.x*blockDim.x + threadIdx.x;
	if (index >= param->num_particles)
		return;
	Particle *p = &particles[index];

#ifdef KERNEL
	p->acc.x = (p->F_SurfaceTension.x + p->F_Pressure.x + p->F_Viscosity.x) / p->dens;
	p->acc.y = (p->F_SurfaceTension.y + p->F_Pressure.y + p->F_Viscosity.y) / p->dens;
	p->acc.z = (p->F_SurfaceTension.z + p->F_Pressure.z + p->F_Viscosity.z) / p->dens;
#endif

	p->vel.x = p->vel.x + p->acc.x*param->timeStep + param->Gravity.x * param->timeStep;
	p->vel.y = p->vel.y + p->acc.y*param->timeStep + param->Gravity.y * param->timeStep;
	p->vel.z = p->vel.z + p->acc.z*param->timeStep + param->Gravity.z * param->timeStep;

	p->pos.x = p->pos.x + p->vel.x *param->timeStep;
	p->pos.y = p->pos.y + p->vel.y *param->timeStep;
	p->pos.z = p->pos.z + p->vel.z *param->timeStep;

	if (p->pos.x >= param->worldSize.x - BOUNDARY)
	{
		p->vel.x = p->vel.x*param->wall_damping;
		p->pos.x = param->worldSize.x - BOUNDARY;
	}

	if (p->pos.x < 0.0f)
	{
		p->vel.x = p->vel.x*param->wall_damping;
		p->pos.x = 0.0f;
	}

	if (p->pos.y >= param->worldSize.y - BOUNDARY)
	{
		p->vel.y = p->vel.y*param->wall_damping;
		p->pos.y = param->worldSize.y - BOUNDARY;
	}

	if (p->pos.y < 0.0f)
	{
		p->vel.y = p->vel.y*param->wall_damping;
		p->pos.y = 0.0f;
	}

	if (p->pos.z >= param->worldSize.z - BOUNDARY)
	{
		p->vel.z = p->vel.z*param->wall_damping;
		p->pos.z = param->worldSize.z - BOUNDARY;
	}

	if (p->pos.z < 0.0f)
	{
		p->vel.z = p->vel.z*param->wall_damping;
		p->pos.z = 0.0f;
	}
}


#ifdef RENDER_MESH

__global__ static void MC_Run(cube* dCubes, Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex) {
	// Each index represents for a cube
	uint index = threadIdx.x + blockDim.x * blockIdx.x;

	if (index >= param->cube_num)
		return;

#if (defined KERNEL)||(defined DF)
	for (int i = 0; i < 8; i++) {
		dCubes[index].vertices[i].val = 0;
		Float3 vert = dCubes[index].vertices[i].pos;
		if (vert.x == 0.0f || vert.x == param->worldSize.x || vert.y == 0.0f || vert.y == param->worldSize.y || vert.z == 0.0f || vert.z == param->worldSize.z)
			continue;
		Uint3 cellPos = computeCellPosition(vert, param);
		Uint3 pos;
		for (int x = -1; x <= 1; x++)
			for (int y = -1; y <= 1; y++)
				for (int z = -1; z <= 1; z++) {
					pos.x = cellPos.x + x;
					pos.y = cellPos.y + y;
					pos.z = cellPos.z + z;
					int hash = computeCellHash(pos, param);
					if (hash < 0 || hash >= param->cells_total)
						continue;
					if (dStart[hash] < 0 || dStart[hash] >= param->num_particles)
						continue;
					uint count = 0;
					for (count = dStart[hash]; count <= dEnd[hash]; count++) {
						Particle *current = &particles[dParticleIndex[count]];
						float distanceSquare = dCalDistance((*current).pos, vert);
						if (distanceSquare > param->h_square)
							continue;
						dCubes[index].vertices[i].val += param->mass * param->poly6_coff * pow(param->h_square - distanceSquare, 3) / current->dens;
					}
				}
	}
#endif

#ifdef SPLINE_KERNEL
	for (int i = 0; i < 8; i++) {
		dCubes[index].vertices[i].val = 0;
		Float3 vert = dCubes[index].vertices[i].pos;
		if (vert.x == 0.0f || vert.x == param->worldSize.x || vert.y == 0.0f || vert.y == param->worldSize.y || vert.z == 0.0f || vert.z == param->worldSize.z)
			continue;
		Uint3 cellPos = computeCellPosition(vert, param);
		Uint3 pos;
		ITERATE_NEIGHBOR{
			pos.x = cellPos.x + x;
		pos.y = cellPos.y + y;
		pos.z = cellPos.z + z;
		int hash = computeCellHash(pos, param);
		if (hash < 0 || hash >= param->cells_total)
			continue;
		if (dStart[hash] < 0 || dStart[hash] >= param->num_particles)
			continue;
		uint count = 0;
		for (count = dStart[hash]; count <= dEnd[hash]; count++) {
			Particle *current = &particles[dParticleIndex[count]];
			float distanceSquare = dCalDistance((*current).pos, vert);
			//if (distanceSquare<ZERO || distanceSquare>param->h_square)
			float distance = sqrt(distanceSquare);
			float q = distance / param->h;
			if (q > 2 || q < 0)
				continue;
			if (q <= 0.5)
				dCubes[index].vertices[i].val += param->mass * (1 - 1.5*pow(q, 2) + 0.75*pow(q, 3)) * param->spline_coff / current->dens;
			else if (q < 1)
				dCubes[index].vertices[i].val += param->mass * (0.25 * pow(2 - q, 3)) *param->spline_coff / current->dens;
			}
		}
	}
#endif
}

// Compute vertices normal
__global__ static void MC_ComputeNormal(cube* dCubes, Param* param) {
	uint index = threadIdx.x + blockDim.x * blockIdx.x;

	if (index >= param->cube_num) return;

	int prev, next;
	for (int i = 0; i < 8; i++) {
		prev = index - 1;
		next = index + 1;
		if (prev < 0 && next >= param->cube_num)
			dCubes[index].vertices[i].norm.x = 0.0f;
		else if (prev < 0)
			dCubes[index].vertices[i].norm.x = (0.0f - dCubes[next].vertices[i].val) / param->cubeSize;
		else if (next >= param->cube_num)
			dCubes[index].vertices[i].norm.x = (dCubes[prev].vertices[i].val - 0.0f) / param->cubeSize;
		else {
			dCubes[index].vertices[i].norm.x = (dCubes[prev].vertices[i].val - dCubes[next].vertices[i].val) / param->cubeSize;
		}


		prev = index - param->cubeCount.x;
		next = index + param->cubeCount.x;
		if (prev < 0 && next >= param->cube_num)
			dCubes[index].vertices[i].norm.y = 0.0f;
		else if (prev < 0)
			dCubes[index].vertices[i].norm.y = (0.0f - dCubes[next].vertices[i].val) / param->cubeSize;
		else if (next >= param->cube_num)
			dCubes[index].vertices[i].norm.y = (dCubes[prev].vertices[i].val - 0.0f) / param->cubeSize;
		else
			dCubes[index].vertices[i].norm.y = (dCubes[prev].vertices[i].val - dCubes[next].vertices[i].val) / param->cubeSize;

		prev = index - param->cubeCount.x * param->cubeCount.y;
		next = index + param->cubeCount.x * param->cubeCount.y;
		if (prev < 0 && next >= param->cube_num)
			dCubes[index].vertices[i].norm.z = 0.0f;
		else if (prev < 0)
			dCubes[index].vertices[i].norm.z = (0.0f - dCubes[next].vertices[i].val) / param->cubeSize;
		else if (next >= param->cube_num)
			dCubes[index].vertices[i].norm.z = (dCubes[prev].vertices[i].val - 0.0f) / param->cubeSize;
		else
			dCubes[index].vertices[i].norm.z = (dCubes[prev].vertices[i].val - dCubes[next].vertices[i].val) / param->cubeSize;

		float norm = -sqrt(dCubes[index].vertices[i].norm.x * dCubes[index].vertices[i].norm.x + dCubes[index].vertices[i].norm.y *dCubes[index].vertices[i].norm.y + dCubes[index].vertices[i].norm.z * dCubes[index].vertices[i].norm.z);

		if (norm == 0.0f) {
			dCubes[index].vertices[i].norm.x = dCubes[index].vertices[i].norm.y = dCubes[index].vertices[i].norm.z = 0.0f;
		}
		else {
			dCubes[index].vertices[i].norm.x /= norm;
			dCubes[index].vertices[i].norm.y /= norm;
			dCubes[index].vertices[i].norm.z /= norm;
		}
	}
}

__global__ static void MC_Run2(cube* dCubes, Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex, Float3* dTriangles, Float3* dNorms) {
	// Each index represents for a cube
	uint index = threadIdx.x + blockDim.x * blockIdx.x;

	if (index >= param->cube_num)
		return;

	for (int i = 0; i < 15; i++) {
		dTriangles[15 * index + i].x = -999.0f;
		dTriangles[15 * index + i].y = -999.0f;
		dTriangles[15 * index + i].z = -999.0f;
		dNorms[15 * index + i].x = -999.0f;
		dNorms[15 * index + i].y = -999.0f;
		dNorms[15 * index + i].z = -999.0f;
	}

	// For a particular cube
	cube *c = &dCubes[index];

	// Determine its situation
	int flag_index = 0;
	if (c->vertices[0].val < param->isovalue) flag_index |= 1;
	if (c->vertices[1].val < param->isovalue) flag_index |= 2;
	if (c->vertices[2].val < param->isovalue) flag_index |= 4;
	if (c->vertices[3].val < param->isovalue) flag_index |= 8;
	if (c->vertices[4].val < param->isovalue) flag_index |= 16;
	if (c->vertices[5].val < param->isovalue) flag_index |= 32;
	if (c->vertices[6].val < param->isovalue) flag_index |= 64;
	if (c->vertices[7].val < param->isovalue) flag_index |= 128;

	int edge_flags = device_cube_edge_flags[flag_index];
	if (edge_flags == 0)
		return;

	// Based on its situation, compute the edge intersection
	Float3 device_edge_vertex[12];
	Float3 device_edge_norm[12];

	for (uint count = 0; count<12; count++)
	{
		if (edge_flags & (1 << count))
		{
			float diff = (param->isovalue - c->vertices[device_edge_conn[count][0]].val) / (c->vertices[device_edge_conn[count][1]].val - c->vertices[device_edge_conn[count][0]].val);

			device_edge_vertex[count].x = c->vertices[device_edge_conn[count][0]].pos.x + (c->vertices[device_edge_conn[count][1]].pos.x - c->vertices[device_edge_conn[count][0]].pos.x) * diff;
			device_edge_vertex[count].y = c->vertices[device_edge_conn[count][0]].pos.y + (c->vertices[device_edge_conn[count][1]].pos.y - c->vertices[device_edge_conn[count][0]].pos.y) * diff;
			device_edge_vertex[count].z = c->vertices[device_edge_conn[count][0]].pos.z + (c->vertices[device_edge_conn[count][1]].pos.z - c->vertices[device_edge_conn[count][0]].pos.z) * diff;

			device_edge_norm[count].x = c->vertices[device_edge_conn[count][0]].norm.x + (c->vertices[device_edge_conn[count][1]].norm.x - c->vertices[device_edge_conn[count][0]].norm.x) * diff;
			device_edge_norm[count].y = c->vertices[device_edge_conn[count][0]].norm.y + (c->vertices[device_edge_conn[count][1]].norm.y - c->vertices[device_edge_conn[count][0]].norm.y) * diff;
			device_edge_norm[count].z = c->vertices[device_edge_conn[count][0]].norm.z + (c->vertices[device_edge_conn[count][1]].norm.z - c->vertices[device_edge_conn[count][0]].norm.z) * diff;
		}
	}

	for (uint count_triangle = 0; count_triangle < 5; count_triangle++)
	{
		if (device_triangle_table[flag_index][3 * count_triangle] < 0)
		{
			break;
		}
		for (uint count_point = 0; count_point < 3; count_point++)
		{
			int tt = device_triangle_table[flag_index][3 * count_triangle + count_point];
			dTriangles[15 * index + 3 * count_triangle + count_point].x = device_edge_vertex[tt].x;
			dTriangles[15 * index + 3 * count_triangle + count_point].y = device_edge_vertex[tt].y;
			dTriangles[15 * index + 3 * count_triangle + count_point].z = device_edge_vertex[tt].z;

			dNorms[15 * index + 3 * count_triangle + count_point].x = device_edge_norm[tt].x;
			dNorms[15 * index + 3 * count_triangle + count_point].y = device_edge_norm[tt].y;
			dNorms[15 * index + 3 * count_triangle + count_point].z = device_edge_norm[tt].z;
		}
	}
}

void MC_RUN_ONE_TIME(cube *dCubes, Particle *dParticles, Param *param, uint* dStart, uint* dEnd, uint* dParticleIndex, Float3*dTriangles, Float3* dNorms, Param* hParam) {
	int MC_thread = 800;
	int MC_block = ceil(hParam->cube_num / (float)MC_thread);
	MC_Run << <MC_block, MC_thread >> > (dCubes, dParticles, param, dStart, dEnd, dParticleIndex);
	MC_ComputeNormal << <MC_block, MC_thread >> > (dCubes, param);

	MC_Run2 << <MC_block, MC_thread >> > (dCubes, dParticles, param, dStart, dEnd, dParticleIndex, dTriangles, dNorms);
}
#endif

bool isKernelSetUp = false;

void GPU(Particle* dParticles, Param* param, uint* dParticleIndex, uint* dCellIndex, uint* dStart, uint* dEnd, cube* dCubes, Float3* dTriangles, Param* hParam)
{
	cudaMemset(dCellIndex, 0xffffffff, hParam->num_particles * sizeof(uint));
	cudaMemset(dParticleIndex, 0xffffffff, hParam->num_particles * sizeof(uint));
	cudaMemset(dStart, 0xffffffff, hParam->cells_total * sizeof(uint));
	cudaMemset(dEnd, 0xffffffff, hParam->cells_total * sizeof(uint));


	generateHashTable << <hParam->BLOCK, hParam->THREAD >> > (dParticles, dParticleIndex, dCellIndex, param);
	sort_particles(dCellIndex, dParticleIndex, hParam->num_particles);
	find_start_end_kernel << <hParam->BLOCK, hParam->THREAD >> > (dStart, dEnd, dCellIndex, dParticleIndex, hParam->num_particles);
	computeDensAndPres << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param, dStart, dEnd, dParticleIndex);
	computeForces << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param, dStart, dEnd, dParticleIndex);
	update << <hParam->BLOCK, hParam->THREAD >> >(dParticles, param);
}

__global__ static void generateHashTable_Boundary(Particle* particles, uint* dParticleIndex, uint* dCellIndex, Param* param) {
	// Each thread represents for a particle
	int index = blockIdx.x * blockDim.x + threadIdx.x;
	if (index >= param->num_boundary_particles)
		return;
	// Compute the cell index
	uint hash = computeCellHash(computeCellPosition(particles[index].pos, param), param);
	if (hash == -1)
		return;
	dParticleIndex[index] = index;
	dCellIndex[index] = hash;
}

__global__
static void computeBorderPsi(Particle* dParticle, Param* param, uint* dParticleIndex, uint* dCellIndex, uint* dStart, uint* dEnd) {
	int index = blockIdx.x * blockDim.x + threadIdx.x;
	if (index >= param->num_boundary_particles)
		return;
	uint hash = computeCellHash(computeCellPosition(dParticle[index].pos, param), param);
	if (hash >= param->cells_total)
		return;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(dParticle[index].pos, param);
	Particle *p = &(dParticle[index]);
	p->Psi = 0;

	ITERATE_NEIGHBOR{
		neighborPos.x = cellPos.x + x;
		neighborPos.y = cellPos.y + y;
		neighborPos.z = cellPos.z + z;
		hash = computeCellHash(neighborPos, param);
		if (hash >= param->cells_total)
			continue;
		if (dStart[hash] < 0 || dStart[hash] >= param->num_boundary_particles)
			continue;
		uint count = 0;
		for (count = dStart[hash]; count <= dEnd[hash]; count++) {
			Particle *j = &dParticle[dParticleIndex[count]];
			float distance = j->pos.Dist(p->pos);
			float q = distance / param->h;
			if (q > 1 || q <= 0)
				continue;

			Float3 deltaR = p->pos - j->pos;

			// Compute Density
			if (q <= 0.5)
				p->Psi += param->spline_coff * (6 * pow(q, 3) - 6 * pow(q, 2) + 1);
			else if (q <= 1)
				p->Psi += param->spline_coff * 2 * pow(1 - q, 3);
		}
	}
	p->Psi = param->rest_density / p->Psi;
}

void ComputeBoundaryParticlePsi(Particle* dParticle, Param* param, uint* dParticleIndex, uint* dCellIndex, uint* dStart, uint* dEnd, Param* hParam) {
	cudaMemset(dCellIndex, 0xffffffff, hParam->num_boundary_particles * sizeof(uint));
	cudaMemset(dParticleIndex, 0xffffffff, hParam->num_boundary_particles * sizeof(uint));
	cudaMemset(dStart, 0xffffffff, hParam->cells_total * sizeof(uint));
	cudaMemset(dEnd, 0xffffffff, hParam->cells_total * sizeof(uint));
#ifdef WINDOWS
	int THREADS = std::fmin(600, hParam->num_boundary_particles);
#endif
#ifdef LINUX
	int THREADS = min(600, hParam->num_boundary_particles);
#endif
	int BLOCKS = ceil(hParam->num_boundary_particles / 600.0f);

	generateHashTable_Boundary << <BLOCKS, THREADS >> > (dParticle, dParticleIndex, dCellIndex, param);
	sort_particles(dCellIndex, dParticleIndex, hParam->num_boundary_particles);
	find_start_end_kernel << <BLOCKS, THREADS >> > (dStart, dEnd, dCellIndex, dParticleIndex, hParam->num_boundary_particles);

	computeBorderPsi << < BLOCKS, THREADS >> > (dParticle, param, dParticleIndex, dCellIndex, dStart, dEnd);
}

#ifdef DF

__global__
static void DFSPHCommputeDensityAndFactorAlpha(Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex,
	Particle* dBoundaryParticles, uint* dBoundaryParticleIndex, uint* dBoundaryCellIndex, uint* dBoundaryStart, uint* dBoundaryEnd) {
	int index = threadIdx.x + blockDim.x*blockIdx.x;
	if (index >= param->num_particles)
		return;
	uint hash;
	uint count = 0;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(particles[index].pos, param);
	Particle *p = &(particles[index]);
	p->dens = param->mass * param->spline_coff;
	p->alpha = 0;
	Float3 temp, temp2;
	temp.x = temp.y = temp.z = 0;
	temp2.x = temp2.y = temp2.z = 0;

	ITERATE_NEIGHBOR{
		neighborPos.x = cellPos.x + x;
		neighborPos.y = cellPos.y + y;
		neighborPos.z = cellPos.z + z;
		hash = computeCellHash(neighborPos, param);
		if (hash >= param->cells_total)
			continue;
		if (dStart[hash] >= 0 && dStart[hash] < param->num_particles){
			for (count = dStart[hash]; count <= dEnd[hash]; count++) {
				Particle *j = &particles[dParticleIndex[count]];
				float distance = j->pos.Dist(p->pos);
				float q = distance / param->h;
				if (q > 1 || q <= 0)
					continue;
	
				Float3 deltaR = p->pos - j->pos;
	
				// Compute Density
				if (q <= 0.5)
					p->dens += param->mass * param->spline_coff * (6 * pow(q, 3) - 6 * pow(q, 2) + 1);
				else if (q <= 1)
					p->dens += param->mass * param->spline_coff * 2 * pow(1 - q, 3);
	
				// Compute Factor Alpha
				if (q <= 0.5) {
					temp2 = param->mass * param->grad_spline_coff * q * (3.0f*q - 2.0f) * deltaR / distance;
					p->alpha += temp2.NormSquare();
					temp += temp2;
				}
	
				else if (q <= 1) {
					temp2 = param->mass * param->grad_spline_coff * (-1) * pow(1.0f - q, 2) * deltaR / distance;
					p->alpha += temp2.NormSquare();
					temp += temp2;
				}
			}
		}


#ifdef ENABLE_BOUNDARY_PARTICLE
		if (dBoundaryStart[hash] < 0 || dBoundaryEnd[hash] >= param->num_boundary_particles)
			continue;
		for (count = dBoundaryStart[hash]; count <= dBoundaryEnd[hash]; count++) {
			Particle *j = &dBoundaryParticles[dBoundaryParticleIndex[count]];
			float distance = j->pos.Dist(p->pos);
			float q = distance / param->h;
			if (q > 1 || q <= 0)
				continue;

			Float3 deltaR = p->pos - j->pos;

			// Compute Density
			if (q <= 0.5)
				p->dens += j->Psi * param->spline_coff * (6 * pow(q, 3) - 6 * pow(q, 2) + 1);
			else if (q <= 1)
				p->dens += j->Psi * param->spline_coff * 2 * pow(1 - q, 3);
			
			// Compute Factor Alpha 
			if (q <= 0.5) {
				temp2 = j->Psi * param->grad_spline_coff * q * (3.0f*q - 2.0f) * deltaR / distance;
				p->alpha += temp2.NormSquare();
				temp += temp2;
			}
			else if (q <= 1) {
				temp2 = j->Psi * param->grad_spline_coff * (-1) * pow(1.0f - q, 2) * deltaR / distance;
				p->alpha += temp2.NormSquare();
				temp += temp2;
			}
		}
#endif
	}


	p->alpha += temp.NormSquare();

	if (p->alpha < 1e-6)
		p->alpha = 1e-6;

	p->alpha = -1.0f / p->alpha;

}

__global__
static void DFSPHComputeNormals(Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex){
	int index = threadIdx.x + blockDim.x*blockIdx.x;
	int hash;
	if (index >= param->num_particles)
		return;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(particles[index].pos, param);
	Particle *p = &(particles[index]);
	p->norm.x = p->norm.y = p->norm.z = 0.0f;
	uint count = 0;

	ITERATE_NEIGHBOR{
		neighborPos.x = cellPos.x + x;
		neighborPos.y = cellPos.y + y;
		neighborPos.z = cellPos.z + z;
		hash = computeCellHash(neighborPos, param);
		if (hash<0 || hash >= param->cells_total)
			continue;
		// If there exists particles in the cell_index
		if (dStart[hash] < param->num_particles){
			for (count = dStart[hash]; count <= dEnd[hash]; count++) {
				Particle *current = &particles[dParticleIndex[count]];
				float distance = current->pos.Dist(p->pos);
				float q = distance / param->h;
				if (q > 1 || q <= 0)
					continue;
				
				Particle j = (*current);
				Float3 deltaR = p->pos - j.pos;

				if (q <= 0.5) {
					p->norm += param->mass * param->grad_spline_coff * q * (3.0f*q - 2.0f) * deltaR / distance / j.dens;
				}
	
				else if (q <= 1) {
					p->norm += param->mass * param->grad_spline_coff * (-1) * pow(1.0f - q, 2) * deltaR / distance / j.dens;
				}
			}
		}
	}

	p->norm = param->h * p->norm;
}

__global__
static void DFSPHComputeForces(Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex) {
	// Suppose now we've got the external forces
	int index = threadIdx.x + blockDim.x*blockIdx.x;
	int hash;
	if (index >= param->num_particles)
		return;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(particles[index].pos, param);
	Particle *p = &(particles[index]);
	p->acc.x = p->acc.z = 0;
	p->acc.y = 0;
	uint count = 0;

	ITERATE_NEIGHBOR{
		neighborPos.x = cellPos.x + x;
		neighborPos.y = cellPos.y + y;
		neighborPos.z = cellPos.z + z;
		hash = computeCellHash(neighborPos, param);
		if (hash<0 || hash >= param->cells_total)
			continue;
		if (dStart[hash] < param->num_particles){
			for (count = dStart[hash]; count <= dEnd[hash]; count++) {
				Particle *current = &particles[dParticleIndex[count]];
				float distance = current->pos.Dist(p->pos);
				float q = distance / param->h;
				if (q > 1 || q <= 0)
					continue;
				// To optimize the calculation process
				Particle j = (*current);
				Float3 delta_v = p->vel - j.vel;
	
				if (q <= 0.5) {
					p->acc -= param->vicosity_coff * (param->mass / j.dens) * delta_v * param->spline_coff * (6 * pow(q, 3) - 6 * pow(q, 2) + 1) / param->timeStep;
				}
	
				else if (q <= 1) {
					p->acc -= param->vicosity_coff * (param->mass / j.dens) * delta_v * param->spline_coff * 2 * pow(1 - q, 3) / param->timeStep;
				}
			}
		}
	}
}

__global__
static void DFSPHComputeSurfaceTensionForce(Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex,
	Particle* dBoundaryParticles, uint* dBoundaryParticleIndex, uint* dBoundaryCellIndex, uint* dBoundaryStart, uint* dBoundaryEnd){
	int index = threadIdx.x + blockDim.x*blockIdx.x;
	int hash;
	if (index >= param->num_particles)
		return;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(particles[index].pos, param);
	Particle *p = &(particles[index]);
	uint count = 0;

	ITERATE_NEIGHBOR{
		neighborPos.x = cellPos.x + x;
		neighborPos.y = cellPos.y + y;
		neighborPos.z = cellPos.z + z;
		hash = computeCellHash(neighborPos, param);
		if (hash<0 || hash >= param->cells_total)
			continue;
		if (dStart[hash] < param->num_particles){
			for (count = dStart[hash]; count <= dEnd[hash]; count++) {
				Particle *current = &particles[dParticleIndex[count]];
				float distance = current->pos.Dist(p->pos);
				float q = distance / param->h;
				if (q > 1 || q <= 0)
					continue;
				// To optimize the calculation process
				Particle j = (*current);
				float K_ij = 2.0 * param->rest_density / (p->dens + j.dens);
				Float3 temp;
				temp.x = temp.y = temp.z = 0.0f;
				Float3 deltaR = p->pos - j.pos;

				if(deltaR.NormSquare() > 1.0e-9){
					deltaR = deltaR * ( 1.0 / deltaR.Norm());
					if(q > 0.5)
						temp -= param->surf_tens_coff * param->mass * deltaR * param->cohesion_coff * pow(param->h - distance, 3) * pow(distance, 3);
					else
						temp -= param->surf_tens_coff * param->mass * deltaR * param->cohesion_coff * 2.0f * pow(param->h - distance, 3) * pow(distance, 3) - param->cohesion_term;
				}

				temp -= param->surf_tens_coff * param->h * (p->norm - j.norm);

				p->acc += K_ij * temp;
			}
		}

#ifdef ENABLE_BOUNDARY_PARTICLE
		if (dBoundaryStart[hash] < param->num_boundary_particles){
			for (count = dBoundaryStart[hash]; count <= dBoundaryEnd[hash]; count++) {
				Particle *j = &dBoundaryParticles[dBoundaryParticleIndex[count]];
				float distance = j->pos.Dist(p->pos);
				float distanceSquare = distance * distance;
				float q = distance / param->h;
				if (q > 1 || q <= 0)
					continue;
	
				Float3 deltaR = p->pos - j->pos;
	
				if(deltaR.NormSquare() > 1.0e-9){
					deltaR = (1.0 / deltaR.Norm()) * deltaR;
					if(q > 0.5)
						p->acc -= param->surf_tens_coff * j->Psi * deltaR * param->Adhesion_coff * pow(-4.0 * distanceSquare / param->h + 6.0f*distance - 2.0f*param->h, 0.25);
				}
			}
		}	
#endif

	}
}

__global__
static void DFSPHComputeVelocityScalar(Particle* particles, Param* param) {
	int index = blockIdx.x*blockDim.x + threadIdx.x;
	if (index >= param->num_particles)
		return;
	Particle *p = &particles[index];
	p->vel_scalar = p->vel.Norm();
}

__global__
static void DFSPHUpdateTimeStep(Particle* particles, Param* param) {
	float max_vel = particles[0].vel_scalar;
	for (int i = 1; i < param->num_particles; i++) {
		if (particles[i].vel_scalar > max_vel)
			max_vel = particles[i].vel_scalar;
	}

	// Use the middle value
	param->timeStep = 0.5 * 0.4 * 2 * param->radius / (max_vel + 1e-6);
	
	if (param->timeStep > 0.005)
		param->timeStep = 0.005;

	else if (param->timeStep < 0.0001)
		param->timeStep = 0.0001;

}

__global__
static void DFSPHPredictVelocity(Particle* particles, Param* param) {
	int index = blockIdx.x*blockDim.x + threadIdx.x;
	if (index >= param->num_particles)
		return;
	Particle *p = &particles[index];

	p->vel.x += param->timeStep * p->acc.x;
	p->vel.y += param->timeStep * (p->acc.y + GRAVITY);
	p->vel.z += param->timeStep * p->acc.z;

}

__global__
static void DFSPHComputeAverageDensity(Particle* particles, Param* param) {
	param->avg_dens = 0;
	for (int i = 0; i < param->num_particles; i++) {
		param->avg_dens += particles[i].dens;
	}
	param->avg_dens /= param->num_particles;
}

__global__
static void DFSPHPredictDensAndVelocity(Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex,
	Particle* dBoundaryParticles, uint* dBoundaryParticleIndex, uint* dBoundaryCellIndex, uint* dBoundaryStart, uint* dBoundaryEnd, int *isGood) {

	int index = threadIdx.x + blockDim.x*blockIdx.x;
	if (index >= param->num_particles)
		return;
	uint hash;
	uint count = 0;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(particles[index].pos, param);
	Particle *p = &(particles[index]);

	p->predict_dens = 0;

	ITERATE_NEIGHBOR{
		neighborPos.x = cellPos.x + x;
		neighborPos.y = cellPos.y + y;
		neighborPos.z = cellPos.z + z;
		hash = computeCellHash(neighborPos, param);
		if (hash >= param->cells_total)
			continue;

		if (dStart[hash] < param->num_particles){
			for (count = dStart[hash]; count <= dEnd[hash]; count++) {
				Particle *j = &particles[dParticleIndex[count]];
				float distance = j->pos.Dist(p->pos);
				float q = distance / param->h;
				if (q > 1 || q <= 0)
					continue;
	
				Float3 deltaR = p->pos - j->pos;
				Float3 deltaV = p->vel - j->vel;
	
				// Compute Density
				if (q <= 0.5)
					p->predict_dens += param->mass * param->grad_spline_coff * q * (3.0f*q - 2.0f) * deltaR.Dot(deltaV) / distance;
				else if (q <= 1)
					p->predict_dens += param->mass * param->grad_spline_coff * (-1) * pow(1.0f - q, 2) * deltaR.Dot(deltaV) / distance;
			}
		}

#ifdef ENABLE_BOUNDARY_PARTICLE

		if (dBoundaryStart[hash] < param->num_boundary_particles){
			for (count = dBoundaryStart[hash]; count <= dBoundaryEnd[hash]; count++) {
				Particle *j = &dBoundaryParticles[dBoundaryParticleIndex[count]];
				float distance = j->pos.Dist(p->pos);
				float q = distance / param->h;
				if (q > 1 || q <= 0)
					continue;
	
				Float3 deltaR = p->pos - j->pos;
				Float3 deltaV = p->vel - j->vel;
	
				// Compute Density
				if (q <= 0.5)
					p->predict_dens += j->Psi * param->grad_spline_coff * q * (3.0f*q - 2.0f) * deltaR.Dot(deltaV) / distance;
				else if (q <= 1)
					p->predict_dens += j->Psi * param->grad_spline_coff * (-1) * pow(1.0f - q, 2) * deltaR.Dot(deltaV) / distance;
			}
		}	
#endif
	}

	p->predict_dens = p->dens + param->timeStep * p->predict_dens;

	if (p->predict_dens < param->rest_density)
		p->predict_dens = param->rest_density;

// CUDA calculation accruary issue
	float dens_err = p->predict_dens - param->rest_density;
	if(dens_err > 1e-6)
		atomicAdd(&param->avg_dens, dens_err);
}

__global__
static void DFSPHClear(Param* param){
	param->avg_dens = 0.0f;
}

__global__
static void DFSPHDensitySolverPart2( Param* param, int *isGood) {
	if(-0.1 < param->avg_dens && param->avg_dens < 0.1){
		*isGood = 1;
		return;
	}
	param->avg_dens = param->avg_dens / param->num_particles;
	if(-0.1 < param->avg_dens && param->avg_dens < 0.1)
		*isGood = 1;
}

__global__
static void DFSPHDensitySolverPart3(Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex,
	Particle* dBoundaryParticles, uint* dBoundaryParticleIndex, uint* dBoundaryCellIndex, uint* dBoundaryStart, uint* dBoundaryEnd, int *isGood) {

	int index = threadIdx.x + blockDim.x*blockIdx.x;
	if (index >= param->num_particles)
		return;
	uint hash;
	uint count = 0;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(particles[index].pos, param);
	Particle *p = &(particles[index]);

	float ki = (p->predict_dens - param->rest_density) * p->alpha / (param->timeStep*param->timeStep);


	float kj = 0;
	ITERATE_NEIGHBOR{
		neighborPos.x = cellPos.x + x;
		neighborPos.y = cellPos.y + y;
		neighborPos.z = cellPos.z + z;
		hash = computeCellHash(neighborPos, param);
		if (hash >= param->cells_total)
			continue;
		if (dStart[hash] < param->num_particles){
			for (count = dStart[hash]; count <= dEnd[hash]; count++) {
				Particle *j = &particles[dParticleIndex[count]];
				float distance = j->pos.Dist(p->pos);
				float q = distance / param->h;
				if (q > 1 || q <= 0)
					continue;
	
				Float3 deltaR = p->pos - j->pos;
				kj = (j->predict_dens - param->rest_density) * j->alpha / (param->timeStep*param->timeStep);
	
				// Prevent instability
				float tk = ki + kj;
				if (-1e-6 >= tk || tk >= 1e-6) {
					if (q <= 0.5) {
						p->vel += param->timeStep * tk * param->mass * param->grad_spline_coff * q * (3.0f*q - 2.0f) * deltaR / distance;
					}
					else if (q <= 1) {
						p->vel += param->timeStep * tk * param->mass * param->grad_spline_coff * (-1) * pow(1.0f - q, 2) * deltaR / distance;
					}
				}
			}
		}

#ifdef ENABLE_BOUNDARY_PARTICLE

		if (dBoundaryStart[hash] < param->num_boundary_particles){
			for (count = dBoundaryStart[hash]; count <= dBoundaryEnd[hash]; count++) {
				Particle *j = &dBoundaryParticles[dBoundaryParticleIndex[count]];
				float distance = j->pos.Dist(p->pos);
				float q = distance / param->h;
				if (q > 1 || q <= 0)
					continue;
	
				Float3 deltaR = p->pos - j->pos;
	
				if (ki <= -1e-6 || ki >= 1e-6) {
					if (q <= 0.5) {
						p->vel += param->timeStep * j->Psi * ki * param->grad_spline_coff * q * (3.0f*q - 2.0f) * deltaR / distance;
					}
	
					else if (q <= 1) {
						p->vel += param->timeStep * j->Psi * ki * param->grad_spline_coff * (-1) * pow(1.0f - q, 2) * deltaR/ distance;
					}
				}
			}
		}
#endif
	}
}

__global__
static void DFSPHUpdatePosition(Particle* particles, Param* param) {
	int index = blockIdx.x*blockDim.x + threadIdx.x;
	if (index >= param->num_particles)
		return;
	Particle *p = &particles[index];
	p->pos += param->timeStep * p->vel;
}

__global__
static void DFSPHComputeGradDensity(Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex,
	Particle* dBoundaryParticles, uint* dBoundaryParticleIndex, uint* dBoundaryCellIndex, uint* dBoundaryStart, uint* dBoundaryEnd) {
	int index = threadIdx.x + blockDim.x*blockIdx.x;
	if (index >= param->num_particles)
		return;
	uint count = 0;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(particles[index].pos, param);
	Particle *p = &(particles[index]);
	p->grad_dens = 0.0f;

	ITERATE_NEIGHBOR{
		neighborPos.x = cellPos.x + x;
	neighborPos.y = cellPos.y + y;
	neighborPos.z = cellPos.z + z;
	int hash;
	hash = computeCellHash(neighborPos, param);
	if (hash < 0 || hash >= param->cells_total)
		continue;
	if (dStart[hash] >= 0 && dStart[hash] < param->num_particles){
		for (count = dStart[hash]; count <= dEnd[hash]; count++) {
			Particle *j = &particles[dParticleIndex[count]];
			float distance = j->pos.Dist(p->pos);
			float q = distance / param->h;
			if (q > 1 || q <= 0)
				continue;
	
			Float3 deltaR = p->pos - j->pos;
			Float3 deltaV = p->vel - j->vel;
	
			// Compute Density Gradient
			if (q <= 0.5)
				p->grad_dens += param->mass  * param->grad_spline_coff * q * (3.0f*q - 2.0f) * (deltaR.x*deltaV.x + deltaR.y*deltaV.y + deltaR.z*deltaV.z) / distance / param->h;
			else if (q <= 1)
				p->grad_dens += param->mass * param->grad_spline_coff * (-1) * pow(1 - q, 2) *(deltaV.x*deltaR.x + deltaR.y*deltaV.y + deltaR.z*deltaV.z) / distance / param->h;
		}
	}

	if (dBoundaryStart[hash] < 0 || dBoundaryStart[hash] >= param->num_boundary_particles)
		continue;
	for (count = dBoundaryStart[hash]; count <= dBoundaryEnd[hash]; count++) {
		Particle *j = &dBoundaryParticles[dBoundaryParticleIndex[count]];
		float distance = j->pos.Dist(p->pos);
		float q = distance / param->h;
		if (q > 1 || q <= 0)
			continue;

		Float3 deltaR = p->pos - j->pos;
		Float3 deltaV = p->vel - j->vel;

		// Compute Density Gradient
		if (q <= 0.5)
			p->grad_dens += j->Psi  * param->grad_spline_coff * q * (3.0f*q - 2.0f) * (deltaR.Dot(deltaV)) / distance / param->h;
		else if (q <= 1)
			p->grad_dens += j->Psi * param->grad_spline_coff * (-1) * pow(1 - q, 2) *(deltaV.Dot(deltaR)) / distance / param->h;
	}
	}
}

__global__
static void DFSPHComputeAverageGradDensity(Particle* particles, Param* param) {
	param->avg_grad_dens = 0;
	for (int i = 0; i < param->num_particles; i++) {
		param->avg_grad_dens += particles[i].grad_dens;
	}
	param->avg_grad_dens /= param->num_particles;
}

__global__
static void DFSPHDivergenceSolver1(Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex,
	Particle* dBoundaryParticles, uint* dBoundaryParticleIndex, uint* dBoundaryCellIndex, uint* dBoundaryStart, uint* dBoundaryEnd, int *isGood) {

	int index = threadIdx.x + blockDim.x*blockIdx.x;
	if (index >= param->num_particles)
		return;
	int hash;
	uint count = 0;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(particles[index].pos, param);
	Particle *p = &(particles[index]);
	p->grad_dens = 0.0f;
	int neighbor_count = 0;

	ITERATE_NEIGHBOR{
		neighborPos.x = cellPos.x + x;
		neighborPos.y = cellPos.y + y;
		neighborPos.z = cellPos.z + z;
		hash = computeCellHash(neighborPos, param);
		if (hash < 0 || hash >= param->cells_total)
			continue;
		if (dStart[hash] >= 0 && dStart[hash] < param->num_particles){
			for (count = dStart[hash]; count <= dEnd[hash]; count++) {
				Particle *j = &particles[dParticleIndex[count]];
				float distance = j->pos.Dist(p->pos);
				float q = distance / param->h;
				if (q > 1 || q <= 0)
					continue;
	
				Float3 deltaR = p->pos - j->pos;
				Float3 deltaV = p->vel - j->vel;
	
				// Compute Density
				if (q <= 0.5)
					p->grad_dens += param->mass  * param->grad_spline_coff * q * (3.0f*q - 2.0f) * (deltaR.Dot(deltaV)) / distance;
				else if (q <= 1)
					p->grad_dens += param->mass * param->grad_spline_coff * (-1) * pow(1 - q, 2) * (deltaR.Dot(deltaV)) / distance;
			}
		}

		if (dBoundaryStart[hash] < 0 || dBoundaryStart[hash] >= param->num_boundary_particles)
			continue;
		for (count = dBoundaryStart[hash]; count <= dBoundaryEnd[hash]; count++) {
			Particle *j = &dBoundaryParticles[dBoundaryParticleIndex[count]];
			float distance = j->pos.Dist(p->pos);
			float q = distance / param->h;
			if (q > 1 || q <= 0)
				continue;

			Float3 deltaR = p->pos - j->pos;
			Float3 deltaV = p->vel - j->vel;
			neighbor_count++;

			// Compute Density Gradient
			if (q <= 0.5)
				p->grad_dens += j->Psi  * param->grad_spline_coff * q * (3.0f*q - 2.0f) * (deltaR.Dot(deltaV)) / distance;
			else if (q <= 1)
				p->grad_dens += j->Psi * param->grad_spline_coff * (-1) * pow(1 - q, 2) *(deltaV.Dot(deltaR)) / distance;
		}
	}


	if (p->grad_dens < 0)
		p->grad_dens = 0;
	if (neighbor_count < 20)
		p->grad_dens = 0;

	// CUDA calculation accruary issue
	if(p->grad_dens>1e-6)
		atomicAdd(&param->avg_grad_dens, p->grad_dens);

}

__global__
static void DFSPHClearV(Param* param){
	param->avg_grad_dens = 0.0f;
}

__global__
static void DFSPHDivergenceSolver2(Param* param, int *isGood) {
	param->avg_grad_dens = param->avg_grad_dens / param->num_particles;
	if (param->avg_grad_dens < (1.0f / param->timeStep))
		*isGood = 1;
}

__global__
static void DFSPHDivergenceSolver3(Particle* particles, Param* param, uint* dStart, uint* dEnd, uint* dParticleIndex,
	Particle* dBoundaryParticles, uint* dBoundaryParticleIndex, uint* dBoundaryCellIndex, uint* dBoundaryStart, uint* dBoundaryEnd, int *isGood) {
	int index = threadIdx.x + blockDim.x*blockIdx.x;
	if (index >= param->num_particles)
		return;
	int hash;
	uint count = 0;
	Uint3 neighborPos;
	Uint3 cellPos = computeCellPosition(particles[index].pos, param);
	Particle *p = &(particles[index]);

	float ki = p->grad_dens * p->alpha / param->timeStep;
	float kj = 0;
	ITERATE_NEIGHBOR{
		neighborPos.x = cellPos.x + x;
		neighborPos.y = cellPos.y + y;
		neighborPos.z = cellPos.z + z;
		hash = computeCellHash(neighborPos, param);
		if (hash < 0 || hash >= param->cells_total)
			continue;
		if (dStart[hash] >= 0 && dStart[hash] < param->num_particles){
			for (count = dStart[hash]; count <= dEnd[hash]; count++) {
				Particle *j = &particles[dParticleIndex[count]];
				float distance = j->pos.Dist(p->pos);
				float q = distance / param->h;
				if (q > 1 || q <= 0)
					continue;
	
				Float3 deltaR = p->pos - j->pos;
				kj = j->grad_dens * j->alpha / param->timeStep;
	
				// Compute Density
				float tk = ki + kj;
				if (tk < -1e-6 || tk > 1e-6) {
					if (q <= 0.5) {
						p->vel += param->timeStep * param->mass * param->grad_spline_coff*(ki + kj) * q * (3.0f*q - 2.0f) * deltaR / distance;
					}
					else if (q <= 1) {
						p->vel += param->timeStep*param->mass * param->grad_spline_coff * (ki + kj) * (-1) * pow(1 - q, 2) * deltaR / distance;
					}
				}
			}
		}

		if (dBoundaryStart[hash] < 0 || dBoundaryStart[hash] >= param->num_boundary_particles)
			continue;
		for (count = dBoundaryStart[hash]; count <= dBoundaryEnd[hash]; count++) {
			Particle *j = &dBoundaryParticles[dBoundaryParticleIndex[count]];
			float distance = j->pos.Dist(p->pos);
			float q = distance / param->h;
			if (q > 1 || q <= 0)
				continue;

			Float3 deltaR = p->pos - j->pos;

			// Compute Density
			if (ki < -1e-6 || ki > 1e-6) {
				if (q <= 0.5) {
					p->vel += param->timeStep * j->Psi * param->grad_spline_coff * (ki)* q * (3.0f*q - 2.0f) * deltaR / distance;
				}
				else if (q <= 1) {
					p->vel += param->timeStep * j->Psi * param->grad_spline_coff * (ki) * (-1) * pow(1 - q, 2) * deltaR / distance;
				}
			}
		}
	}
}

__global__
static void CheckMem(Particle* dParticles, Param* param) {
	printf("CheckMem\n");
	//printf("Velocity of particle 5: %f,%f,%f\n", dParticle[5].vel.x, dParticle[5].vel.y, dParticle[5].vel.z);
	//printf("%f,%f\n", dParticle[5].dens, dParticle[5].alpha);
	printf("NUM_PARTICLE: %f\n", param->num_particles);
	printf("TimeStep: %f\n", param->timeStep);
	double ccc = 0;
	for(int i = 0; i < param->num_particles; i++){
		printf("%f\n",dParticles[i].predict_dens - param->rest_density);
		if(dParticles[i].predict_dens - param->rest_density>1e-6)
			ccc = ccc + (dParticles[i].predict_dens - param->rest_density);
		printf("%f\n", ccc);
	}
	printf("CCC: %f\n", ccc);
	printf("CheckMem\n");
}

// The first fram generating process is a little bit different. Thus, I made it an individual method
void DFSPHSetUp(Particle* dParticles, Param* param, uint* dParticleIndex, uint* dCellIndex, uint* dStart, uint* dEnd, cube* dCubes, Float3* dTriangles, Param* hParam,
	Particle* dBoundaryParticles, uint* dBoundaryParticleIndex, uint* dBoundaryCellIndex, uint* dBoundaryStart, uint* dBoundaryEnd) {

	// These four variables are used in neighbor fingding process
	// Initialize them with 0xffffffff
	cudaMemset(dCellIndex, 0xffffffff, hParam->num_particles * sizeof(uint));
	cudaMemset(dParticleIndex, 0xffffffff, hParam->num_particles * sizeof(uint));
	cudaMemset(dStart, 0xffffffff, hParam->cells_total * sizeof(uint));
	cudaMemset(dEnd, 0xffffffff, hParam->cells_total * sizeof(uint));

	// For all particles , find neighborhoods.
	generateHashTable << <hParam->BLOCK, hParam->THREAD >> > (dParticles, dParticleIndex, dCellIndex, param);
	sort_particles(dCellIndex, dParticleIndex, hParam->num_particles);
	find_start_end_kernel << <hParam->BLOCK, hParam->THREAD >> > (dStart, dEnd, dCellIndex, dParticleIndex, hParam->num_particles);

	// Compute Density and Factor alpha
	// 
	DFSPHCommputeDensityAndFactorAlpha << <hParam->BLOCK, hParam->THREAD >> >(dParticles, param, dStart, dEnd, dParticleIndex, dBoundaryParticles, dBoundaryParticleIndex, dBoundaryCellIndex, dBoundaryStart, dBoundaryEnd);
}

#ifdef TIMER
#ifdef DENSITY_SOLVER_TIMER
PhysicalEngineTimer densitySolverTimer(DENSITYSOVLER_TIMEDATA_FILEAPTH);
#endif
#ifdef DIVERGENCE_SOLVER_TIMER
PhysicalEngineTimer divergenceSolverTimer(DIVERGENCESOLVER_TIMEDATE_FILEPATH);
#endif
#ifdef NEIGHBOR_SEARCHING_TIMER
PhysicalEngineTimer neighborSearchingTimer(NEIGHBOR_SEARCHING_TIMEDATA_FILEPATH);
#endif
#endif

void DFSPHLoop(Particle* dParticles, Param* param, uint* dParticleIndex, uint* dCellIndex, uint* dStart, uint* dEnd, cube* dCubes, Float3* dTriangles, Param* hParam,
	Particle* dBoundaryParticles, uint* dBoundaryParticleIndex, uint* dBoundaryCellIndex, uint* dBoundaryStart, uint* dBoundaryEnd) {

	// Calculate all the non-pressure force
	DFSPHComputeNormals << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param, dStart, dEnd, dParticleIndex);
	// In this method, I only compute the viscous force. We've got another method for surface tension force computation and we add the gravity force at last.
#ifdef VISCOUS_FORCE
	DFSPHComputeForces << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param, dStart, dEnd, dParticleIndex);
#endif
	// The surface tension force computing method.
#ifdef SURFACE_TENSION
	DFSPHComputeSurfaceTensionForce << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param, dStart, dEnd, dParticleIndex, dBoundaryParticles, dBoundaryParticleIndex, dBoundaryCellIndex, dBoundaryStart, dBoundaryEnd);
#endif
	// Adapt time step size and predict the velocity
	// Just simply calculate the velocity scalar of each particle
	DFSPHComputeVelocityScalar << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param);
	// Update the timestep using CFL condition
	DFSPHUpdateTimeStep << <1, 1 >> >(dParticles, param);
	// Make the prediction of velocity based on the newly computeted Advection force and timestep
	DFSPHPredictVelocity << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param);


	// Density Error Solver //
	// isGood variable is to indicate if the solver has solved the problem.
	// While in our case, it indicates that if the error rate reaches the goal.
#if (defined DIVERGENCE_SOLVER)||(defined DENSITY_SOLVER)
	int hIsGood = 0;
	int *dIsGood;
	cudaMalloc((void**)&dIsGood, sizeof(int));
	cudaMemcpy(dIsGood, &hIsGood, sizeof(int), cudaMemcpyHostToDevice);
	int volatile counter = 0;
#endif
#ifdef DENSITY_SOLVER
	// After each iteration, we can get a newly predicted velocity which will give the paritcles' position of next frame
	// The Lagrangian method computes the density of the paritcle through the distribution of its neightboring particles
	// Thes we can calculate the average density of particles in the next frame
	// If the difference between next frame and current frame is less than the threshold, then we can quit the solver and announce that the density has been adjusted.
	// But in case of the non-convergent result, we set the maximal iteration time to 100
#if defined(TIMER) && defined(DENSITY_SOLVER_TIMER)
	densitySolverTimer.start();
#endif
	while ((hIsGood == 0 || counter < 2) && counter < 100) {
		// Clear the average density.
		DFSPHClear<<<1,1>>>(param);
		// Bad method name. Actually , I only predicted the density in the method. No velocity is predicted in this method.
		DFSPHPredictDensAndVelocity << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param, dStart, dEnd, dParticleIndex, dBoundaryParticles, dBoundaryParticleIndex, dBoundaryCellIndex, dBoundaryStart, dBoundaryEnd, dIsGood);
		// Compute the new velocty prediction
		DFSPHDensitySolverPart3 << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param, dStart, dEnd, dParticleIndex, dBoundaryParticles, dBoundaryParticleIndex, dBoundaryCellIndex, dBoundaryStart, dBoundaryEnd, dIsGood);
		// Judge if the termination condition is met
		DFSPHDensitySolverPart2 << <1, 1 >> > (param, dIsGood);
		cudaMemcpy(&hIsGood, dIsGood, sizeof(int), cudaMemcpyDeviceToHost);
		printf("DENSITY SOLVER ITERATION %d\n", counter);
		counter++;
	}
#if defined(TIMER) && defined(DENSITY_SOLVER_TIMER)
	densitySolverTimer.end();
#endif
#endif
	// Density Error Solver //


	// Update the position of all particles
	DFSPHUpdatePosition << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param);


	// Rehashing
#if defined(TIMER) && defined(NEIGHBOR_SEARCHING_TIMER)
	neighborSearchingTimer.start();
#endif
	cudaMemset(dCellIndex, 0xffffffff, hParam->num_particles * sizeof(uint));
	cudaMemset(dParticleIndex, 0xffffffff, hParam->num_particles * sizeof(uint));
	cudaMemset(dStart, 0xffffffff, hParam->cells_total * sizeof(uint));
	cudaMemset(dEnd, 0xffffffff, hParam->cells_total * sizeof(uint));
	generateHashTable << <hParam->BLOCK, hParam->THREAD >> > (dParticles, dParticleIndex, dCellIndex, param);
	sort_particles(dCellIndex, dParticleIndex, hParam->num_particles);
	find_start_end_kernel << <hParam->BLOCK, hParam->THREAD >> > (dStart, dEnd, dCellIndex, dParticleIndex, hParam->num_particles);
#if defined(TIMER) && defined(NEIGHBOR_SEARCHING_TIMER)
	neighborSearchingTimer.end();
#endif
	// Calculate the new density and alpha factor based on the new particle position.
	DFSPHCommputeDensityAndFactorAlpha << <hParam->BLOCK, hParam->THREAD >> >(dParticles, param, dStart, dEnd, dParticleIndex, dBoundaryParticles, dBoundaryParticleIndex, dBoundaryCellIndex, dBoundaryStart, dBoundaryEnd);

	// Divergence Error Solver //
#ifdef DIVERGENCE_SOLVER
	hIsGood = 0;
	counter = 0;
	cudaMemcpy(dIsGood, &hIsGood, sizeof(int), cudaMemcpyHostToDevice);
#if defined(TIMER) && defined(DIVERGENCE_SOLVER_TIMER)
	divergenceSolverTimer.start();
#endif
	while ((hIsGood == 0 || counter < 1) && counter < 100) {
		DFSPHClearV<<<1,1>>>(param);
		DFSPHDivergenceSolver1 << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param, dStart, dEnd, dParticleIndex, dBoundaryParticles, dBoundaryParticleIndex, dBoundaryCellIndex, dBoundaryStart, dBoundaryEnd, dIsGood);
		DFSPHDivergenceSolver3 << <hParam->BLOCK, hParam->THREAD >> > (dParticles, param, dStart, dEnd, dParticleIndex, dBoundaryParticles, dBoundaryParticleIndex, dBoundaryCellIndex, dBoundaryStart, dBoundaryEnd, dIsGood);
		DFSPHDivergenceSolver2 << <1,1 >> > (param, dIsGood);
		cudaMemcpy(&hIsGood, dIsGood, sizeof(int), cudaMemcpyDeviceToHost);
		printf("DIVERGENCE SOLVER ITERATION %d\n", counter);
		counter++;
	}
#if defined(TIMER) && defined(DIVERGENCE_SOLVER_TIMER)
	divergenceSolverTimer.end();
#endif
#endif
	// Divergence Error Solver //


	printf("\n");
#if (defined DIVERGENCE_SOLVER)||(defined DENSITY_SOLVER)
	cudaFree(dIsGood);
#endif
}

#endif
